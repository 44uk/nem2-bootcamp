== ローカルネットワークの構築

`Symbol` ネットワークはそれぞれの役割を担うノードが複数連携して構築されます。
本章では、ネットワークのノード群を簡単に構築できる `symbol-service-bootstrap` という開発ツールキットを用いて、
ローカルマシンにブロックチェーンネットワークを構築します。


=== Docker / Docker Compose のインストール

`Docker / Docker Compose` を公式サイトに従い、各プラットフォーム向けの方法でインストールしてください。
それぞれコマンドパスが通っている状態にしてください。

[source,shell]
----
$ docker -v
Docker version 19.03.5, build 633a0ea
$ docker-compose -v
docker-compose version 1.24.1, build 4667896b
----


=== symbol-service-bootstrap のダウンロード

`tech-bureau/symbol-service-bootstrap` のGitHubリポジトリから取得します。
`git clone` またはアーカイブのダウンロードなどのお好みの方法で取得してください。

[source,shell]
----
$ git clone https://github.com/tech-bureau/symbol-service-bootstrap.git -b 0.9.1.1-public-test
$ cd symbol-service-bootstrap
----

クローンまたはアーカイブを展開したら、カレントディレクトリを移動してください。
以降、カレントディレクトリはクローンしたプロジェクトのディレクトリを前提とします。


=== ブロックチェーンネットワークの立ち上げ

ノード群を立ち上げます。ここでは用意されているコマンドスクリプトを実行します。

[source,shell]
----
$ ./cmds/start-all -d <1>
Step 1/5 : FROM alpine:3.7
 ---> 3fd9065eaf02
Step 2/5 : RUN apk add --no-cache ruby ruby-bundler
 ---> Running in f0d369dd6e1a
(省略)
----
<1> -d オプション:バックグラウンド実行(daemon)

初回起動時にはDockerイメージのダウンロードに時間がかかります。
その後、ノードの初期設定ファイルの生成、初期ブロックの生成などが実行され、各種ノードが生成されたファイルを読み込み、ブロックチェーンネットワークのノード群が稼働を始めます。


=== ノード群の停止

作業を止める場合など、ノード群を停止するには `./cmds/stop-all` を実行します。

[source,shell]
----
$ ./cmds/stop-all
----

再開する場合は再度 `./cmds/start-all -d` を実行します。


== ブロックチェーンの確認

ブロックチェーンネットワークにはAPIゲートウェイを経由してアクセスします。
`Symbol` ではブロックチェーンデータへのアクセスにAPIゲートウェイが提供するインターフェイスを使います。


=== APIゲートウェイから情報取得

正しくチェーンが稼働していることを確認するために、APIゲートウェイのエンドポイントにアクセスしてブロックの生成を確認します。
次のようなレスポンスが得られます。ちなみにこれはチェーンの最新ブロック高を取得しています。

.レスポンス例 http://localhost:3000/block/1
[source,shell]
----
{"height":"38"}
----

もし上記のようなレスポンスが得られず、起動に失敗している場合は後述のトラブルシュートを参考にしてください。

実際のアプリケーション開発では、トランザクション送信に複雑な署名処理が必要になるため、SDKを用いた開発が推奨されます。

続く節ではJavaScript用のSDKを用いて情報取得やトランザクション発信を行いますが、
HTTPリクエストが実行できれば、如何なる環境からでもブロックチェーンを利用できます。


=== 初期分配モザイクの確認

`NEM2（Symbol）` はプレマイン型チェーンです。
基軸モザイクとして `8,999,999,999 nem.xem` が総発行され、発行された基軸モザイクは初期生成アドレスへ分配されます。

初期生成アドレスは `./build/generated-addresses/addresses.yml` に保存されます。
`nemesis_addresses:` という箇所から下にアドレスが30件ほど並びます。

./build/generated-addresses/addresses.yml nemesis_addresses例
[source,yaml]
----
nemesis_addresses:
- private: 791107322244D47D71F3A7CBD71C6BAC50D34554D094DB12E7C37BD3167AE70F
  public: 2ADD369D13AF5E3C9B628E1CA4CF7D48C0A9031EAE3BD1BDF21DC22B54DDFE02
  address: SB7CEHTBPPP7NHTKBXWFU7A44T5RFF7GO5OJQWCF
(省略)
----

アカウントは秘密鍵（ `private` ）、公開鍵（ `public` ）、アドレス（ `address` ）の3つの情報を持ちます。
ちなみに公開鍵、アドレスは秘密鍵から導出できます。

ここでは一番目のアカウントを使用します。 `address` の文字列をコピーして、次のURLにアクセスします。
なお、生成される鍵は生成ごとにランダムなので、以降ではアドレスや鍵の値をご自身の環境で生成された値で置き換えてください。

アカウントレスポンス例（整形済み）
[source,json]
----
{ "meta": {},
  "account": {
    "address": "907E221E617BDFF69E6A0DEC5A7C1CE4FB1297E6775C985845",
    "addressHeight": [ 1, 0 ],
    "publicKey":"0000000000000000000000000000000000000000000000000000000000000000",
    "publicKeyHeight": [ 0, 0 ],
    "accountType": 0,
    "linkedAccountKey": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA=",
    "activityBuckets": [
      { "startHeight": "1", "totalFeesPaid": "0",
        "beneficiaryCount": 0, "rawScore": "3750000" }
    ],
    "mosaics": [
      { "id": [ 2758936655, 46307174 ], "amount": [ 636036448, 104762 ] },
      { "id": [ 1572847029, 1861856425 ], "amount": [ 3750000, 0 ] }
    ],
    "importance": [ 3750000, 0 ],
    "importanceHeight": [ 1, 0 ]
} }
----

`mosaics` の配列が保有モザイクを表しています。
ここでは2つのモザイクの保有を示していますが、 `[636036448, 104762]` に注目します。

値は `JavaScript` で64bitの大きな値を扱うために上下位32bitずつに分けた表現になっています。
次のワンライナースクリプトで読みやすい整数値へ変換します。

[source,shell]
----
$ node -e "console.log(104762 * 0x100000000 + 636036448)"
449949999900000
----

`[636036448, 104762]` のうち `104762` が上位 `32bit` なので `0x100000000` を乗じてシフトし、
`636036448` は下位 `32bit` なのでこの2つを加算します。
結果として `449949999900000` という数値が得られました。

初期配布される基軸モザイクは `nem.xem` と命名され、可分性は `6` と定義されているので、
`449,949,999.900,000 nem.xem` が分配されていることが確認できました。

以後、基軸通貨が必要な場合はこのアカウントから必要な分を転送することで利用できます。
